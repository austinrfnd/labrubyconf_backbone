<!DOCTYPE html>
<html>
  <head>
    <title>Presentation</title>

    <meta charset='utf-8' />
    <link href='styles.css' rel='stylesheet' type='text/css' />
    <link href="rainbow/themes/solarized-light.css" rel="stylesheet" type="text/css" />
    <script src='google_slides.js'></script>
    <script src="rainbow/rainbow.min.js"></script>
    <script src="rainbow/language/generic.js"></script>
    <script src="rainbow/language/ruby.js"></script>
    <script src="rainbow/language/coffeescript.js"></script>

  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen template-default'>

      <article>
        <h1>Rails, Backbone.js, and (a little Jasmine)</h1>
        <h2 class="subtitle">LaRubyConf 2013</h2>
        <p>by Austin Fonacier (and Danny Banks)</p>
      </article>
      
      <article>
        <h3>Who I Am</h3>
        <h4 class='subtitle'>Spokeo</h4>
        <h5>Software Architect</h5>
      </article>

      <article>
        <h3>Who We Are</h3>
        <h4 class='subtitle'>Blogmate</h4>
        <h4 class='subtitle'>Ben, Danny, Austin</h4>
        <ul class="build">
          <li>Ben: Business, product and voice of reason</li>
          <li>Austin: Ruby, Rails, and screwing up Danny's CSS</li>
          <li>Danny: Design, Javascript, CSS, and everything</li>
        </ul>
      </article>

      <article>
        <h3>Warning!!!</h3>
        <ul class="build">
          <li>I'm not a javascript expert</li>
          <li>I'm not a Ruby or Rails expert</li>
          <li>I'm just a semi-decent user of existing tools</li>
          <li>I'm just just sharing my experiences of using tools and the outcome it has on our product</li>
          <li>All javascript examples are in CoffeeScript</li>
        </ul>
      </article>

      <article>
        <h3>Tech Introduction: Rails</h3>
        <h4 class='subtitle'>http://rubyonrails.org/</h4>
        <ul class="build">
          <li>Ruby Framework</li>
          <li>MVC Architecture</li>
          <li>TDD Driven</li>
          <li>REST-ful</li>
          <li>Not much else on this...</li>
        </ul> 
      </article>

      <article>
        <h3>Tech Introduction: Jasmine</h3>
        <h4 class='subtitle'>http://pivotal.github.com/jasmine/</h4>
        <ul class="build">
          <li>BDD framework for testing Javascript</li>
          <li>RSPEC-ish style</li>
          <li>Jasmine gem for Ruby based integration</li>
          <li>Can integrate with Selenium and continuous integraiton environments</li>
        </ul> 
      </article>

      <article>
        <h3>Tech Introduction: Backbone.js</h3>
        <h4 class='subtitle'>http://backbonejs.org/</h4> 
        <ul class='build'>
          <li>Javascript framework</li>
          <li>MV* framework</li>
          <li>Routes</li>
          <li>Dependency: underscore.js</li>
          <li>Template agnostic</li>
          <li>Small: 6kb</li>
          <li>Just getting your appetite wet...</li>
        </ul>
      </article>


      <article>
        <h3>Enough Bullet Points</h3>
        <h4>Let's Get Into It</h4>
        <img class='centered' src='img/yayyy.gif' />
      </article>

      <article>
        <h3>Blogmate: Pre-backbone</h3>
        <ul class='build'>
          <li>Projects may often start with built-in Rails helpers (EX: link_to_remote)</li>
          <li>Blogmate bypassed that.</li>
          <li>Every view had a view class.</li>
          <li>Every model had a model class.</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>Blogmate: Pre-backbone The Model</h3>
<pre><code data-language="coffeescript">
class @List
  constructor:(attrs) ->
    @id = attrs['id']
    @name = attrs['name']
    @description = attrs['description']
    @username = attrs['username']

  save: ->
    data = {list: {name: @name, description: @description}, _method:"POST" , format: 'json'}
    # If we have an ID, I'll assume it's an update
    if @id
      data["_method"] = "PUT"
      data['id'] = @id
      $.post "/lists/"+@id, data, this.after_update.bind(this), 'json'
    # If we dont' have an id I'll assume it's a create
    else
      $.post("/lists/", data, this.after_create.bind(this), 'json').status

  destroy: ->
    $.post "/lists/"+@id, {id: @id, _method:"DELETE", format: 'json'}, this.after_destroy.bind(this), 'json'
  
  # callbacks
  after_destroy: (data, status) ->
    # Do whatever we need to after we destroy

  after_update: (data, status) ->
    # Do whatever we need to after we update

  after_create: (data, status) -> 
    # Do whatever we  need to after we create

</code></pre>
      </article>

      <article class='smaller'>
        <h3>Blogmate: Pre-backbone The View</h3>
<pre><code data-language="coffeescript">
class @Article
  init: ->
    this.cacheElements()
    this.bindEvents()
    this.renderAll()

  cacheElements: ->
    this.$appWrapper         = $('#app_wrapper')
    this.$overlay            = $('#highlight_overlay')

  bindEvents: ->
    $(document).on('mouseenter mouseleave', '.highlight, .annotation', this.highlightHover)
    $(document).on('click', '.annotation_edit', this, this.editAnnotation)

  renderAll: ->
    # Render stuff to the DOM
</code></pre>
      </article>

      <article>
        <h3>Blogmate: Pre-backbone</h3>
        <h4 class='subtitle'>The Problems</h4>
        <ul class='build'>
          <li>When we wrote our first revision of javascript we thought we were hot shit.</li>
          <li>Everything was organized, object-ified, clean, and just worked.</li>
          <li>Until we tried to update view(s) on model save, update and destroys.</li>
        </ul>
      </article>

      <article>
<!--
  So here we wanted to show that when a list item (article), gets destroyed, there are multiple views that get updated
-->
        <h3>Blogmate: Pre-backbone</h3>
        <img class='centered' src="img/list_show.png" />
      </article>

      <article>
        <h3>Blogmate: Pre-backbone</h3>
        <img class='centered' src="img/list_show_after.png" />
      </article>

      <article>
<!--
  This is sampe of the haml view from the above slides.
  Notice that multiple views use the same model.
-->
        <h3>Blogmate: Pre-backbone</h3>
        <pre><code data-language='erb'>
:javascript
  articles = []
  <% @articles.each do |article| %>
    articles.push(new Article(<%= @article.to_json %>))
  <% end %>
  article_collection = new ArticleCollection(articles)
  list = new List(<%= @list.to_json %>)
  # bottom part with all the lists
  list_view = new ListView({model: list, articles: article_collection})
  # Top part with all the stats
  list_info = new ListInfo({model: list, articles: article_collection})
        </code></pre>
      </article>

      <article>
<!--
  So it looks ok right? but it's not.
  Because article.destroy is an async callback to the server.
  So given this is the way it is, the view doesn't REALLY know if the article has been destroy or not.
  Because that "knowledge" of it actually being destroy is in the article model's after_destroy function!

  We only realized this when there was a bug in our backend that wouldn't actually destroy an article but
  the view would update anyways.

  Also this bug applies to any updates and creates where we wanted our Javascript models to persist the data
  coming back from the server.
-->
        <h3>Blogmate: Pre-backbone</h3>
        <pre><code data-language='coffeescript'>
class @ListView
  destroy_article: (article) ->
    if article.destroy
      $("#article_#{article.id}").remove
        </code></pre>
      </article>

      <article>
<!--
  So we thought about pushing view updating into the model.
  It made sense for all of 10 seconds.  Why are we passing models into views initializers and also views into saves, updates and destroys?

  This doesn't make any sense.  It literally creates a web of code and callbacks that is unsustainable.
-->
        <h3>Blogmate: Pre-backbone</h3>
        <pre><code data-language='coffeescript'>
class @Article
  destory(list_view, article_view): ->
    $.post "/lists/"+@id, {id: @id, _method:"DELETE", format: 'json'}, this.after_destroy.bind(this), 'json'
  # callbacks
  after_destroy: (data, status) ->
    article_view.after_article_destroy(data['id'])
    list_view.after_article_destroy(data['id'])
        </code></pre>
      </article>     

      <article>
        <h3>Backbone: Model</h3>
        <p>Core of backbone, a model has a 1-1 correlation with a model in Rails</p>
<pre><code data-language="coffeescript">
class @Annotation extends Backbone.Model
  initialize: (attrs) ->
    @annotation_text   = attrs['annotation_text']
    @highlighted_text  = attrs['highlighted_text']
    @user_id           = attrs['user_id']
    @id                = attrs['id']
    @users_articles_id = attrs['users_articles_id']

  url: ->
    u = "/annotations"
    u = "#{u}/#{@id}" if @id
    u
</code></pre>
      </article>

      <article>
        <h3>Backbone: Model (cont).</h3>
        <ul class='build'>
          <li>Similar-ish to ActiveRecord models</li>
          <li>Expects JSON from the backend</li>
          <li>Assumes a 
      </article>REST backend</li>
        </ul>
          <p>
            GET /articles/1
            POST /articles
            PUT /articles/1
            DELETE /articles/1
          </p>

      <article>
        <h3>Backbone: Model (cont)</h3>
        <h4 class="subtitle">get, set, save, destroy</h4>
        <p>All you need is basic CRUD methods in your backend and you can start CRUDing in backbone</p>
<pre><code data-language="coffeescript">@model.get('key') # would return 'value'
@model.set({ key: 'value' })
@model.destroy({
  success: (response) ->
  error: (response) ->
})
@model.save({ key: 'value' }, {
  sucess: (model,response) ->
  error: (response) ->
})
</code></pre>
      </article>

      <article>
        <h3>Backbone: Collection</h3>
        <p>A collection of models, in rails you can just give it a JSON'd array of objects and all the models get populated</p>
<pre><code data-language="coffeescript">class @AnnotationCollection extends Backbone.Collection
  model: Annotation

  initialize: ->

  url: ->
</code></pre>
<pre><code data-language="coffeescript">annotationCollection = new AnnotationCollection( 
  <%= @users_article.annotations.to_json() %> 
);
</code></pre>
      </article>

      <article>
        <h3>Backbone: View (cont)</h3>
        <p> The view example represents the highlighted box.</p>
        <img class='centered' src="img/list_show_highlight.png" />
      </article>

      <article>
        <h3>Backbone: View</h3>
        <p>View is convention of code organization.  It is very flexible.  We will scratch the surface</p>
<pre><code data-language="coffeescript">class @ListView extends Backbone.View
  
  tagName: 'li'
  template: SMT['list_item']

  initialize: (attrs) ->
    @model.on('change', this.render)
    @model.on('destroy', this.render)
    this.render()

  events: {

  }

  render: =>
    this.$el.html( this.template(@model.toJSON()) )
    return this
</code></pre>
      </article>

      <article>
        <h3>Did not cover: Routes</h3>
        <p>Backbone also has routing that is very similar to the way Rails does routes.</p>
        <p>You could make a single page app and handle all links in Backbone if you wanted to.</p>
        <p>Wasn't part of blogmate v1 but Danny has a branch implementation out soon.</p>
      </article>

      <article>
        <h3>For More Info:</h3>
        <ul>
          <li><a href="#">http://addyosmani.github.com/backbone-fundamentals/</a></li>
          <li>http://backboneboilerplate.com/</li>
          <li>http://documentcloud.github.com/backbone/docs/backbone.html</li>
          <li>http://documentcloud.github.com/backbone/docs/todos.html</li>
          <li>I will also glady walk you  through my whole JS architecture in JS.</li>
        </ul>
      </article>

      <article>
        <img class='centered' src="img/gangnam_haters.gif" />
      </article>

    </section>

  </body>
</html>
